#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("v8-compile-cache");
const axios_1 = __importDefault(require("axios"));
const chalk_1 = __importDefault(require("chalk"));
const clear_module_1 = require("clear-module");
const findhelp_1 = require("findhelp");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const ramda_1 = require("ramda");
const pkg = __importStar(require("../package.json"));
const CLIPrechecker_1 = require("./CLIPreChecker/CLIPrechecker");
const conf = __importStar(require("./conf"));
const env_1 = require("./env");
const errors_1 = require("./errors");
const Token_1 = require("./lib/auth/Token");
const TelemetryCollector_1 = require("./lib/telemetry/TelemetryCollector");
const logger_1 = __importDefault(require("./logger"));
const tree_1 = __importDefault(require("./modules/tree"));
const nps_1 = require("./nps");
const update_1 = __importDefault(require("./update"));
const utils_1 = require("./utils");
const run = command => Promise.resolve(findhelp_1.run.call(tree_1.default, command, path_1.default.join(__dirname, 'modules')));
const logToolbeltVersion = () => {
    logger_1.default.debug(`Toolbelt version: ${pkg.version}`);
};
const loginCmd = tree_1.default.login;
let loginPending = false;
const checkLogin = args => {
    const first = args[0];
    const whitelist = [undefined, 'config', 'login', 'logout', 'switch', 'whoami', 'init', '-v', '--version', 'release'];
    const token = new Token_1.Token(conf.getToken());
    if (!token.isValid() && whitelist.indexOf(first) === -1) {
        logger_1.default.debug('Requesting login before command:', args.join(' '));
        return run({ command: loginCmd });
    }
};
const main = async () => {
    const args = process.argv.slice(2);
    conf.saveEnvironment(conf.Environment.Production); // Just to be backwards compatible with who used staging previously
    logToolbeltVersion();
    logger_1.default.debug('node %s - %s %s', process.version, os_1.default.platform(), os_1.default.release());
    logger_1.default.debug(args);
    await checkLogin(args);
    const command = await findhelp_1.find(tree_1.default, ramda_1.without([utils_1.VERBOSE], args));
    if (utils_1.isVerbose) {
        const findWhoami = await findhelp_1.find(tree_1.default, ['whoami']);
        if (command.command !== findWhoami.command) {
            await run(findWhoami);
        }
    }
    await nps_1.checkAndOpenNPSLink();
    await run(command);
};
const onError = async (e) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const status = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status;
    const statusText = (_b = e === null || e === void 0 ? void 0 : e.response) === null || _b === void 0 ? void 0 : _b.statusText;
    const headers = (_c = e === null || e === void 0 ? void 0 : e.response) === null || _c === void 0 ? void 0 : _c.headers;
    const data = (_d = e === null || e === void 0 ? void 0 : e.response) === null || _d === void 0 ? void 0 : _d.data;
    const code = (e === null || e === void 0 ? void 0 : e.code) || null;
    if (headers) {
        logger_1.default.debug('Failed request headers:', headers);
    }
    if (status === 401) {
        if (!loginPending) {
            logger_1.default.error('There was an authentication error. Please login again');
            // Try to login and re-issue the command.
            loginPending = true;
            return run({ command: loginCmd }).then(() => {
                clear_module_1.all();
                main();
            }); // TODO: catch with different handler for second error
        }
        return; // Prevent multiple login attempts
    }
    if (status) {
        if (status >= 400) {
            const message = data ? data.message : null;
            const source = e.config.url;
            logger_1.default.error('API:', status, statusText);
            logger_1.default.error('Source:', source);
            if ((_e = e.config) === null || _e === void 0 ? void 0 : _e.method) {
                logger_1.default.error('Method:', e.config.method);
            }
            if (message) {
                logger_1.default.error('Message:', message);
                logger_1.default.debug('Raw error:', data);
            }
            else {
                logger_1.default.error('Raw error:', {
                    data,
                    source,
                });
            }
        }
        else {
            logger_1.default.error('Oops! There was an unexpected error:');
            logger_1.default.error(e.read ? e.read().toString('utf8') : data);
        }
    }
    else if (code) {
        switch (code) {
            case 'ENOTFOUND':
                logger_1.default.error('Connection failure :(');
                logger_1.default.error('Please check your internet');
                break;
            case 'EAI_AGAIN':
                logger_1.default.error('A temporary failure in name resolution occurred :(');
                break;
            default:
                logger_1.default.error('Unhandled exception');
                logger_1.default.error('Please report the issue in https://github.com/vtex/toolbelt/issues');
                if (((_f = e.config) === null || _f === void 0 ? void 0 : _f.url) && ((_g = e.config) === null || _g === void 0 ? void 0 : _g.method)) {
                    logger_1.default.error(`${e.config.method} ${e.config.url}`);
                }
                logger_1.default.debug(e);
        }
    }
    else {
        switch (e.name) {
            case findhelp_1.MissingRequiredArgsError.name:
                logger_1.default.error('Missing required arguments:', chalk_1.default.blue(e.message));
                break;
            case findhelp_1.CommandNotFoundError.name:
                logger_1.default.error('Command not found:', chalk_1.default.blue(...process.argv.slice(2)));
                break;
            case errors_1.CommandError.name:
                if (e.message && e.message !== '') {
                    logger_1.default.error(e.message);
                }
                break;
            case errors_1.SSEConnectionError.name:
                logger_1.default.error((_h = e.message) !== null && _h !== void 0 ? _h : 'Connection to login server has failed');
                break;
            case errors_1.UserCancelledError.name:
                logger_1.default.debug('User Cancelled');
                break;
            default:
                logger_1.default.error('Unhandled exception');
                logger_1.default.error('Please report the issue in https://github.com/vtex/toolbelt/issues');
                logger_1.default.error('Raw error:', e);
        }
    }
    process.removeListener('unhandledRejection', onError);
    const errorReport = TelemetryCollector_1.TelemetryCollector.getCollector().registerError(e);
    logger_1.default.error(`ErrorID: ${errorReport.errorId}`);
    TelemetryCollector_1.TelemetryCollector.getCollector().flush();
    process.exit(1);
};
axios_1.default.interceptors.request.use(config => {
    if (env_1.envCookies()) {
        config.headers.Cookie = `${env_1.envCookies()}; ${config.headers.Cookie || ''}`;
    }
    return config;
});
process.on('unhandledRejection', onError);
const start = async () => {
    CLIPrechecker_1.CLIPrechecker.getCLIPrechecker(pkg).runChecks();
    // Show update notification if newer version is available
    update_1.default();
    try {
        await main();
        TelemetryCollector_1.TelemetryCollector.getCollector().flush();
    }
    catch (err) {
        await onError(err);
    }
};
start();
